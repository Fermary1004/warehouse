# 영어 자기 소개

I feel happy to have an interview for a job in a good company like SK planet. My name is Oh, Myung Woon. I'm a software engineer who delights in programming.

I've been using Java as a main language. I have made a lot of Java web applications and a UML modeling tool which is not so common in Korea. I could go deeper into the OOP thanks to the development of that UML modeling tool.

I enjoy learning something new, and I'm in WebGL which can make high performance 3D or 2D graphics in the web browser. And I'm also studying design patterns in JavaScript in some developer community. Recently I started reading a book on blockchain.  

I think I might be the right man for this job because I have experiences in working with Americans. I was a KATUSA, so I carried out my 26-month military duty in the United States Army. Although I did not have that much chance to work with English speaking people since then, still I can communicate in English better than the average software engineer in Korea.

# 컴퓨터 구조

## 메인보드

- 버스 : 메인 보드에 연결된 여러 기기의 데이터 교환 통로
- 칩셋 : 메인 보드에 연결된 여러 기기의 전기적 특성 차이를 흡수해서 데이터의 전송 타이밍과 흐름 제어
    - north bridge : 메인메모리, 그래픽카드 등 고속 기기 흐름 제어
    - south bridge : HDD, USB, 마우스, 키보드 등 저속 기기 흐름 제어
- OS의 역할 : 프로그램에 실행 환경 제공
    - 프로세스 제어, 메모리 관리, 파일 시스템 관리, 사용자 인터페이스 제공
    
## 컴퓨터의 부팅

- ROM BIOS에서 주변기기 체크, 하드웨어 리소스 할당 등을 담당하는 프로그램을 읽어서 실행
- ROM BIOS에서 읽은 프로그램에 HDD의 MBR을 읽어오라는 명령 포함
- MBR의 부트로더를 읽어서 파티션 테이블 인식
- 파티션의 부트 섹터에서 OS 프로그램을 메모리에 로딩해서 OS 실행

## CPU 구성 및 동작 원리

- 연산 유닛, 제어 유닛, 레지스터, 외부인터페이스
- fetch, decode, execute, output

## 프로그램 실행 과정

- OS가 프로그램을 메모리에 로딩하고, CPU의 세그먼트 레지스터(코드, 데이터, 스택 세그먼트)에 실행할 프로그램에 대한 세그먼트 값 할당
- 프로그램에 저장되어 있는 오프셋 값을 읽어 가면서 필요한 코드와 데이터를 계속 메모리에서 읽으면서 프로그램 실행

## 메모리 파편화

### 내부 파편화

### 외부 파편화



# 인터넷 구조

## How internet works(done)

- Internet is not a cloud but a wire

- Server is a special computer connected to the internet

- Client - ISP - Internet

- Email sending - Packet - rebuild

- Router
내 IP를 담아 보내서 첫번째 라우터를 거치면 
첫번째 라우터 IP로 다음 경로를 탄다
이렇게 라우터를 탈 때 마다 wrapping 된다.
서버에서 회신할 때는 Wrapping한 IP대로 계속 다음 라우터로 전달(Stack과 유사)


## OSI 7계층(done)

하위 3계층은 중간 노드에서 모두 구현
상위 4개층은 종단 노드에서만 구현
계층별 수평선은 프로토콜 의미
즉 프로토콜은 다른 머신 간의 같은 레이어
서비스는 같은 머신 내의 다른 레이어

Application : HTTP, FTP, SMTP
Presentation : encryption, 32bit int <-> 64bit int
Session : 영상 채팅 시 비디오와 오디오를 한 세션에 묶어준다
Transport : 메시지가 누락없이 순서에 맞게 전송되는지 검송
Network : 메시지를 패킷으로 나눠서 전송, 올바른 종착지로 패킷이 전송되도록하는 라우팅 책임(PC, 라우터, 스위치 등등)
Data Link : 패킷을 프레임으루 나눠서 raw bytes 전송, 데이터 인코딩, 데이터 프레이밍, 에러 디텍션/커렉션, 
Physical : raw bit 전담

https://www.youtube.com/watch?v=O_rsqVtaloI

## HTTPS

- SSL(정식 명칭은 TLS, Transport Layer Security)을 이용하는 HTTP 통신
- 성능 최적화를 위해 대칭키 암호화 방식과 공개키 암호화 방식을 섞어서 사용한다.

### 대칭키 암호화

- 전통적인 방식의 암호화로 암호화 할 때와 복호화 할 때 동일한 대칭키를 사용한다.
- 암복호화를 위해 대칭키를 양방이 모두 가지고 있어야 하므로, 일방에서 타방으로 대칭키를 필연적으로 보내야 하며, 따라서 대칭키의 유출 위험이 크다.
- 대칭키는 암복호화 시 자원 소모량이 적다.

### 공개키 암호화

- 수학적으로 한 쌍을 이루는 공개키(public key)와 개인키(private key) 생성
- 공개키로 암호화 한 원문은 개인키로만 복호화 할 수 있고, 개인키로 암호화 한 원문은 공개키로만 복호화 할 수 있다.
- 개인키는 누구와도 교환할 필요 없이 스스로 잘 간직하면 되므로 보안성이 높지만, 암복호화 하는데 자원이 많이 소모된다.


### CA

- 어떤 사이트의 안전성을 보증해주는 공인된 보증 기관
    - Symantec, GoDaddy 등
- 브라우저는 CA의 목록과 각 CA의 공개키를 가지고 있다.
- 서비스 운영자는 사이트의 정보와 서비스 서버의 공개키를 CA에 제출하고 CA 인증서 발급 신청
- CA는 서비스 서버의 정보와 서비스 서버의 공개키를 CA의 개인키로 암호화 한 CA 인증서를 발급

### 클라이언트의 브라우저가 CA 인증서를 검증

- 클라이언트가 서버에 접속할 때 클라이언트의 랜덤 데이터(A라 하자)를 서버 측에 전달하고, 서버는 클라이언트에게 CA 인증서와 하나의 랜덤 데이터(B라 하자)를 회신한다.
- 클라이언트의 브라우저는 자신이 가지고 있는 CA 목록과 CA의 공개키를 이용해서 CA 인증서를 복호화 한다.
    - 브라우저가 자신이 가진 공개키로 CA 인증서 복호화에 성공했다는 것은 CA 인증서가 CA의 개인키로 암호화 되었음을 의미하므로, CA 인증서가 유효하다는 것을 의미한다.
    - 만약 브라우저가 아니라 악의의 제3자가 CA 목록과 CA 공개키를 알고 있다면, 제3자도 CA의 인증서를 복호화 할 수 있다. 하지만 복호화 해봐야 알 수 있는 정보는 서비스 사이트의 일반 정보와 서비스 서버의 공개키 등 애초부터 공개되어도 괜찮은 정보만 얻을 수 있으므로 아무런 위험에 노출되지 않는다.

### 전자 서명

- CA 인증서와 마찬가지 방식으로, 공개되어도 괜찮은 정보만을 자신의 개인키로 암호화해서 인증서를 만들고, 이 인증서와 자신의 공개키를 함께 발송하면 자신이 개인키를 가진 사람이라는 것을 안전하게 입증할 수 있다.
- 즉, 공개되어도 괜찮은 정보만을 자신의 개인키로 암호화해서 인증서를 만들고, 이 인증서와 자신의 공개키를 함께 발송하는 것을 **전자 서명**이라고 한다.

### 클라이언트와 서버의 데이터 교환

>**양이 많은 실제 데이터는 대칭키로 암복호화 하고, 양이 적은 대칭키만 상대방의 공개키로 암호화 해서 성능 저하를 회피한다.**

- 전자 서명 확인 과정에서 클라이언트는 서버의 공개키를 알게 되었다.
- 클라이언트는 A와 B를 조합해서 pre master secret를 생성하고, 이 키를 서버의 공개키로 암호화 해서 서버에게 보낸다.
- 서버는 클라이언트가 보낸 pre master secret를 서버 자신의 개인키로 복호화한다. 이제 클라이언트와 서버는 제3자에게는 알려지지 않은 안전한 pre master secret를 공유하게 되었다.
- 클라이언트와 서버는 몇 번의 교환을 더 거쳐 pre master secret를 이용해서 master secret를, master secret를 이용해서 session key를 생성한다. 
- 이 session key는 클라이언트와 서버가 실제 교환하는 데이터를 암복호화 하는 대칭키로 사용된다.
- 클라이언트는 서버에 보낼 민감 정보 데이터를 session key로 암호화 하고, session key를 서버의 공개키로 암호화 해서 서버에게 보낸다.
- 서버는 서버 자신의 공개키로 session key를 복호화 하고, 복호화 한 session key로 클라이언트가 보낸 실제 데이터를 복호화해서 실제 데이터를 알아낸다.
    - 제3자는 서버의 개인키를 가지고 있지 않으므로 session key를 복호화 할 수 없고, 따라서 실제 데이터도 알아낼 수 없다.
- 클라이언트와 서버의 연결이 종료되면 양방 모두 session key를 폐기한다.


# 객체지향

- 객체에게 데이터를 요구하지 말고, 작업을 요청하라.

## SOLID

- Single Reponsibility Principle
    - 객체는 단 하나의 책임만 가져야 하고, 객체를 변경하는 이유도 단 하나여야 한다. 
    - 책임도 추상화 정도에 따라 객체의 책임, 메서드의 책임으로 분류할 수 있으므로, SRP는 객체 뿐 아니라 메서드 수준에서도 적용될 수 있다.

- Open Closed Principle
    - 확장에는 열려있어야 하고 변경에는 닫혀있어야 한다.
    - 기존 코드를 변경하지 않고 기능을 확장할 수 있어야 한다.
    - mocking을 쉽게 할 수 있게 해주므로 테스팅 용이성 증가
    - 전략 패턴

- Liskov Substitution Principle
    - 부모가 사용된 곳에는 어떤 자식이 사용되어도 바르게 동작해야 한다.
    - 자식이 부모의 행위(메서드)를 override 하면 LSP를 만족하지 못한다.
    - 정사각형이 직사각형을 상속하는 경우가 LSP를 어기는 대표적인 예
        - 정사각형은 setHeight, setWidth가 필요하지 않으며, setSide만 필요하다.
        - is-a 관계가 성립할 것 같지만, 직사각형을 파라미터로 받는 메서드에 정사각형을 넣으면 제대로 동작하지 않을 수 있다.
        
- Interface Segregation Principle
    - 인터페이스를 책임에 맞게 분리하여 인터페이스에 의존하는 객체의 의존성을 제한한다.
    - SRP가 객체의 책임 분리라면 ISP는 인터페이스의 책임 분리
    - 복합기와 프린터 클라이언트, 스캐너 클라이언트, 복사기 클라이언트

- Dependency Inversion Principle
    - 상위 모듈은 하위 모듈에 의존하지 말고, 하위 모듈을 추상화 한 상위 모듈에 의존해야 한다.
    - 인터페이스에 의존하도록 해서 DI와 함께 유연성 증가

## Refactoring(31)
  - 원칙, 기법



# Frameworks

## Vert.x
- not a framework but a library
- event bus
- hazelcast, Full GC 위험
- reactive programming
- vs node.js
- vs akka

## Spring
- DI
    - 헐리우드 원칙, Don't call us, we will call you
    - 의존하는 객체를 직접 지목해서 사용하지 않고, 제공받아서 사용하는 방식
    - 인터페이스와 함께 사용해서 코드의 결합도를 낮추고, 테스팅성을 높인다.
- 서비스 추상화
    - 메일 전송, 트랜잭션 관리 등 애플리케이션 단에서 담당해야할 서비스를, 추상화한 인터페이스에 의존하게해서 특정 기술에 대한 종속 방지
- AOP
    - 인증, 로깅, 트랜잭션 설정 등 여러 범위에 걸치는 공통 로직을 프록시나 바이트코드 위빙을 통해 비즈니스 로직을 수정하지 않고 적용하는 프로그래밍 방식


# Language

## Java
- JVM
    - 메모리 구조
    - 가비지 컬렉션
    - 덤프
- Annotation
- Concurrent, Parallel
- Serialization(done)
- Java8


## Python
- 기본 문법
    - 동적 타입
    - 들여 쓰기
    - #, """
    - 문자열에 ', " 모두 사용 가능
    - len(문자열), str(비문자열) : 문자열이 아닌 데이터에도 사용가능하므로 .len(), .str()이 아님
    - 문자열.lower(), 문자열.upper() : 문자열에만 사용할 수 있는 메서드라 .lower() 형태로 사용
    - 문자열[인덱스] 
    - 문자열 + 숫자 자동형변환 안함
    - 문자열도 for char in string 가능
    - 문자열도 str[start:end:stride] 가능
    - " ".join(list) : list의 원소를 " "로 구분하는 문자열 반환  
    - print("%s %s" % (val1, val2))
    - 행 바꾸기는 \
    - now = datetime.now(), now.year/month/day/hour/minute/second 
    - 논리연산자 우선순위 not, and, or
    - if :, elif :, else :
    - 함수(*args) - list도 그냥 list라 쓰던데 *는 뭔지 모르겠음
    - while : else : 문이 있음, else 이하는 break 아닌 정상 종료 시 수행
    - for : else : 문도 있음, else 이하는 break 아닌 정상 종료 시 수행
    - range(n) : 0~n-1까지의 list 반환
    - raw_input(str) : 콘솔에서 사용자 입력 접수
    - print sth, : 한 행에 이어서 출력
    - for index, item in enumerate(list):
    - zip(list1, list2, list3, ...) : list1, 2, 3을 동시에 루핑 돌면서 동일한 인덱스의 각 원소쌍 반환
    - lambda x, y, z: 함수 바디
    - filter(lambda, list)
    - 비트연산 <<, >>, &, |, ^, ~
 
- 자료 구조
    - List : []
        - .append(item)
        - list[start:end] : start는 없으면 0으로 간주, end는 없으면 len(list)로 간주
        - .index(val) : val 값의 index반환
        - .insert(i)
        - .remove(val) : 반환값 없음
        - .pop(index) : index위치에 있는 값 반환
        - .del(val) : 반환값 없음 - remove와 뭐가 다르지??
        - .sort()
        - sorted(list)
        - len(list) : 리스트 길이 반환
        - list + list : 두 리스트의 원소를 모두 합친 하나의 리스트
        - not in list 연산자 가능
        - list comprehension - i for i in range(51) if i % 2 == 0
        - list slicing - list[start\: end:stride], start, end, stride 모두 없을 수도 있다
        - list[::-1] 은 리스트를 역순으로 정렬, -10도 가능
         
    - Dictionary : {}, dic[key]
        - javascript와 거의 유사
        - del dic[key]
        - .items()
        - .keys()
        - .values()

    - 진법
        - bin(숫자) : 0b### 형태의 이진수 반환
        - int(nstr, b) : b진수로 된 숫자문자열n을 10진 정수로 변환

    - class
        - __init__(self, para1, para2):
        - 호출 시 ClassNam3(para1, para2)와 같이 호출 
            ```python
            class MyClass(ParentClass):
                classVar = True
                def __init__(self, para1, para2):
                    self.instanceVar1 = para1
                    self.instanceVar2 = para2

            MyClass('param1', 'param2')
            ``` 
        - 모든 메서드의 정의부에 첫번째 인자로 self를 명시
        - 멤버 변수를 지칭할 떄도 self.멤버변수 로 써야함
        - super(ChildClassName, self)로 Parent 클래스 지칭 가능
        - __repr__(): - java의 Object.toString()인듯
        - static 메서드 호출하는 것과 비슷하게 Class이름.메서드(인스턴스) 방식으로 호출 가능
            
            ```python
            class Dog:
                def cry(self):
                    print("왈왈")

            a_dog = Dog()
            a_dog.cry() // '왈왈' 출력
            Dog.cry(a_dog) // '왈왈' 출력
            ```

    - I/O
        - open(path, mode)
            - r : readonly
            - r+ : read and write
            - w : write
            - a : append
        - file.write(문자열)
        - file.close()
        - file.readline()
        - with open(file, mode) as textfile 로 하면 file.close()가 내부적으로 자동 호출

- Design Pattern 구현
  - Strategy
  - State
  - Template Method
  - Template Callback
  - Composite
  - Visitor
  - Proxy
  - Decorator
  - Adapter
  - Iterator
  - Command


# Database

- SQL
- 인덱싱
- 샤딩
- 2-phase commit
- NoSQL vs RDBMS
- 2중화

## RDBMS


## NoSQL

### Document

### Column

### 기타


## ORM



# Big Data

## Map-Reduce

- 정돈되지 않은 데이터를 map을 통해 레이블링 하면서 정돈하고,
- 레이블에 따라 reduce하면서 간추리고 집계한다.

## HDFS

## Storm

## Spark

- RDD 생성 및 반환
    - 프로그램 내부 : sc.parallelize(list) - 단일 머신 내에서만 구동되는 RDD
    - SparkContext.textFile()
- 주요 Transformation
    - .map(func)
    - .filter(func)
    - .flatMap(func)
    - .distinct() : 비싸다
    - rdd1.union(rdd2)
    - rdd1.intersection(rdd2)
    - rdd1.subtract(rdd2)
    - rdd1.cartesian(rdd2)
- 주요 Action
    - .collect()
    - .count()
    - .countByValue()
    - .take(num)
    - .top(num)
    - .reduce(func)
    - .fold(zero)(func)
    - .foreach(func)
- 지연 처리
    - Transformation은 Action이 실행될 때에 비로소 함께 실행된다. 
- 영속화
    - .persist(영속화레벨)
    - .unpersist()
- Pair RDD
    - .reduceByKey(func)
    - .groupByKey(func)
    - .combineByKey(생성컴바이너, 생성값, 병합컴바이너, 병합값) 
- Word Count
    - lines = sc.textFile("file")
    - words = lines.flatMap(lambda x: x.split(" "))
    - count1 = words.countByValue()
    - count2 = words.map(lambda x: (x, 1)).reduceByKey(lambda x, y: x + y) 
- 클러스터 운영


# 경험

## Fresto

### FrontEnd성능 데이터 추출
- JavaScript UUID
```javascript
function getUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
    }); 
}
console.log( getUUID() ); //3bce4931-6c75-41ab-afe0-2ec108a30860
```
- AJAX 가로채기
    - 성능 데이터 항목

        ```javascript
        var request_event = {
            stage: 'HTTP_REQUEST',
            uuid: callUuid,
            clientId: clientIP,
            referrer: window.location.href,
            targetUrl: href,
            method: 'GET',
            requestTimestamp: request_timestamp
        }
	```
 
    - 성능 데이터 가로채기

        ```javascript
        $(document).ready(function() {
        	$('a').on("click", interceptClick);
        	$('area').on("click", interceptClick);
        });
        ```

    - 성능 데이터 발송
    
        ```javascript
        function interceptClick(e) {
            var href = this.href;
            var target = this.target;

            var callUuid = randomUUID();
            var request_timestamp = new Date().getTime();
            var request_event = {
                stage: 'HTTP_REQUEST',
                uuid: callUuid,
                clientId: clientIP,
                referrer: window.location.href,
                targetUrl: href,
                method: 'GET',
                requestTimestamp: request_timestamp
            }

            $.post('http://fresto1.owlab.com:9999/feedUIEvent',request_event); 

            $.ajax({
                type: 'GET',
                beforeSend: function(request) {
                    request.setRequestHeader('fresto-uuid', callUuid);
                },
                url: href, 
                success: function(data) { 
                	var response_timestamp = new Date().getTime();
                	var response_event = {
                        stage: 'HTTP_RESPONSE',
                        uuid: callUuid,
                        clientId: clientIP,
                        referrer: window.location.href,
                        targetUrl: href,
                        method: 'GET',
                        requestTimestamp: request_timestamp,
                        responseTimestamp: response_timestamp,
                        elapsedTime: (response_timestamp - request_timestamp),
                        httpStatus: 200
                	}
                	$.post('http://fresto1.owlab.com:9999/feedUIEvent', response_event); 
                	window.history.pushState('Programmed State','JPetStore', href);
                	$('body').html(data); 
                	//document.write(data);
                }
            });

            // To disable the default action.
            e.preventDefault();
        }
        ```
    - 서버 수집 쪽에 CORS 처리 필요

### BackEnd 성능 데이터 수집

- 서버 구간 별 성능 데이터 발송
    - 성능 데이터 항목
        - 클래스, 메서드, TimeStamp, 쿼리문
    - 성능 데이터 수집 방식
        - In
            - Servlet : Servlet Filter
            - Controller : SpringMVC Interceptor preHandle
            - Service : SpringAOP @Before Advice implements MethodInterceptor
            - DAO : SpringAOP @Before Advice implements MethodInterceptor
        - Out
            - DAO : SpringAOP @After Advice implements MethodInterceptor
            - Service : SpringAOP @After Advice implements MethodInterceptor
            - Controller : SpringMVC Interceptor postHandle
            - View : SpringMVC Interceptor afterCompletion
    - 성능 데이터 발송
        - Aspect 내에서 ZeroMQ로 EventHub로 발송


## gradnet
- 어려웠던 점, 해결 사례
    - 위변조 방지 처리된 PDF
        - 제출 PDF를 하나로 합쳐달라는 요구사항
        - 위변조 방지 PDF는 합칠 때 오류, 업로드 시 합침 테스트로 위변조 방지 PDF 필터링
    - BIRT 라이브러리
        - HTTP 요청으로만 동작하던 BIRT 라이브러리
        - 내부 메서드에서 호출 가능한 방식으로 재구성
    - S3 배치 다운로드
        - s3object를 큐에 담아놓고 나중에 로컬에 저장하게 구성되어 간헐적으로 연결 리셋
        - s3object에서 바로 inputstream을 뽑아서 바로 로컬에 저장

