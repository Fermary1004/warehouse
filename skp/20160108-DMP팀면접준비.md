# How internet works(done)

- Internet is not a cloud but a wire

- Server is a special computer connected to the internet

- Client - ISP - Internet

- Email sending - Packet - rebuild

- Router
내 IP를 담아 보내서 첫번째 라우터를 거치면 
첫번째 라우터 IP로 다음 경로를 탄다
이렇게 라우터를 탈 때 마다 wrapping 된다.
서버에서 회신할 때는 Wrapping한 IP대로 계속 다음 라우터로 전달(Stack과 유사)


# OSI 7계층(done)

하위 3계층은 중간 노드에서 모두 구현
상위 4개층은 종단 노드에서만 구현
계층별 수평선은 프로토콜 의미
즉 프로토콜은 다른 머신 간의 같은 레이어
서비스는 같은 머신 내의 다른 레이어

Application : FTP
Presentation : 32bit int <-> 64bit int
Session : 영상 채팅 시 비디오와 오디오를 한 세션에 묶어준다
Transport : 메시지가 누락없이 순서에 맞게 전송되는지 검송
Network : 메시지를 패킷으로 나눠서 전송, 올바른 종착지로 패킷이 전송되도록하는 라우팅 책임(PC, 라우터, 스위치 등등)
Data Link : 패킷을 프레임으루 나눠서 raw bytes 전송, 데이터 인코딩, 데이터 프레이밍, 에러 디텍션/커렉션, 
Physical : raw bit 전

https://www.youtube.com/watch?v=O_rsqVtaloI

# Vert.x
- reactive programming
- not a framework but a library
- vs node.js
- vs akka



# Spring(28~30)
- DI
    - 헐리우드 원칙, Don't call us, we will call you
    - 의존하는 객체를 직접 지목해서 사용하지 않고, 제공받아서 사용하는 방식
    - 인터페이스와 함께 사용해서 코드의 결합도를 낮추고, 테스팅성을 높인다.
- 서비스 추상화
    - 메일 전송, 트랜잭션 관리 등 애플리케이션 단에서 담당해야할 서비스를, 추상화한 인터페이스에 의존하게해서 특정 기술에 대한 종속 방지
- AOP
    - 인증, 로깅, 트랜잭션 설정 등 여러 범위에 걸치는 공통 로직을 프록시나 바이트코드 위빙을 통해 비즈니스 로직을 수정하지 않고 적용하는 프로그래밍 방식

# SOLID

- Single Reponsibility Principle
    - 객체는 단 하나의 책임만 가져야 하고, 객체를 변경하는 이유도 단 하나여야 한다.
    - 

- Open Closed Principle
    - 확장에는 열려있어야 하고 변경에는 닫혀있어야 한다.
    - 전략 패턴

- Liskov Substitution Principle
    - 부모가 사용된 곳에는 어떤 자식이 사용되어도 바르게 동작해야 한다.
    - 정사각형이 직사각형을 상속하는 경우가 LSP를 어기는 대표적인 예
        - 정사각형은 setHeight, setWidth가 필요하지 않으며, setSide만 필요하다.
        - is-a 관계가 성립할 것 같지만, 직사각형을 파라미터로 받는 메서드에 정사각형을 넣으면 제대로 동작하지 않을 수 있다.
        
- Interface Segregation Principle
    -  인터페이스를 책임에 맞게 분리하여 인터페이스에 의존하는 객체의 의존성을 제한한다.

- Dependency Inversion Principle
    - 상위 모듈은 하위 모듈에 의존하지 말고, 하위 모듈의 추상에 의존해야 한다.
    - 

# Refactoring(31)
  - 원칙, 기법


# Python(26-27)
- 기본 문법
    - 동적 타입
    - 들여 쓰기
    - #, """
    - 문자열에 ', " 모두 사용 가능
    - len(문자열), str(비문자열) : 문자열이 아닌 데이터에도 사용가능하므로 .len(), .str()이 아님
    - 문자열.lower(), 문자열.upper() : 문자열에만 사용할 수 있는 메서드라 .lower() 형태로 사용
    - 문자열[인덱스] 
    - 문자열 + 숫자 자동형변환 안함
    - 문자열도 for char in string 가능
    - 문자열도 str[start:end:stride] 가능
    - " ".join(list) : list의 원소를 " "로 구분하는 문자열 반환  
    - print("%s %s" % (val1, val2))
    - 행 바꾸기는 \
    - now = datetime.now(), now.year/month/day/hour/minute/second 
    - 논리연산자 우선순위 not, and, or
    - if :, elif :, else :
    - 함수(*args) - list도 그냥 list라 쓰던데 *는 뭔지 모르겠음
    - while : else : 문이 있음, else 이하는 break 아닌 정상 종료 시 수행
    - for : else : 문도 있음, else 이하는 break 아닌 정상 종료 시 수행
    - range(n) : 0~n-1까지의 list 반환
    - raw_input(str) : 콘솔에서 사용자 입력 접수
    - print sth, : 한 행에 이어서 출력
    - for index, item in enumerate(list):
    - zip(list1, list2, list3, ...) : list1, 2, 3을 동시에 루핑 돌면서 동일한 인덱스의 각 원소쌍 반환
    - lambda x, y, z: 함수 바디
    - filter(lambda, list)
    - 비트연산 <<, >>, &, |, ^, ~
 
- 자료 구조
    - List : []
        - .append(item)
        - list[start:end] : start는 없으면 0으로 간주, end는 없으면 len(list)로 간주
        - .index(val) : val 값의 index반환
        - .insert(i)
        - .remove(val) : 반환값 없음
        - .pop(index) : index위치에 있는 값 반환
        - .del(val) : 반환값 없음 - remove와 뭐가 다르지??
        - .sort()
        - sorted(list)
        - len(list) : 리스트 길이 반환
        - list + list : 두 리스트의 원소를 모두 합친 하나의 리스트
        - not in list 연산자 가능
        - list comprehension - i for i in range(51) if i % 2 == 0
        - list slicing - list[start\: end:stride], start, end, stride 모두 없을 수도 있다
        - list[::-1] 은 리스트를 역순으로 정렬, -10도 가능
         
    - Dictionary : {}, dic[key]
        - javascript와 거의 유사
        - del dic[key]
        - .items()
        - .keys()
        - .values()

    - 진법
        - bin(숫자) : 0b### 형태의 이진수 반환
        - int(nstr, b) : b진수로 된 숫자문자열n을 10진 정수로 변환

    - class
        - __init__(self, para1, para2):
        - 호출 시 ClassNam3(para1, para2)와 같이 호출 
            ```python
            class MyClass(ParentClass):
                classVar = True
                def __init__(self, para1, para2):
                    self.instanceVar1 = para1
                    self.instanceVar2 = para2

            MyClass('param1', 'param2')
            ``` 
        - 모든 메서드의 정의부에 첫번째 인자로 self를 명시
        - 멤버 변수를 지칭할 떄도 self.멤버변수 로 써야함
        - super(ChildClassName, self)로 Parent 클래스 지칭 가능
        - __repr__(): - java의 Object.toString()인듯

    - I/O
        - open(path, mode)
            - r : readonly
            - r+ : read and write
            - w : write
            - a : append
        - file.write(문자열)
        - file.close()
        - file.readline()
        - with open(file, mode) as textfile 로 하면 file.close()가 내부적으로 자동 호출

- Design Pattern 구현(28-1/5)
  - Strategy
  - State
  - Template Method
  - Template Callback
  - Composite
  - Visitor
  - Proxy
  - Decorator
  - Adapter
  - Iterator
  - Command



# Java
- JVM
    - 메모리 구조
    - 가비지 컬렉션
    - 덤프
- Annotation
- Concurrent, Parallel
- Serialization(done)




# Database(31)
  - SQL
  - 인덱싱
  - 샤딩
  - 2-phase commit
  - NoSQL vs RDBMS
  - 2중화





# Spark(27)
  - 주요 Transformation
  - 주요 Action
  - 클러스터 운영



# 성능 데이터 추출(fresto)
- JavaScript UUID
```javascript
function getUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
    }); 
}
console.log( getUUID() ); //3bce4931-6c75-41ab-afe0-2ec108a30860
```
- AJAX 가로채기
    - 성능 데이터 항목

        ```javascript
        var request_event = {
            stage: 'HTTP_REQUEST',
            uuid: callUuid,
            clientId: clientIP,
            referrer: window.location.href,
            targetUrl: href,
            method: 'GET',
            requestTimestamp: request_timestamp
        }
	```
 
    - 성능 데이터 가로채기

        ```javascript
        $(document).ready(function() {
        	$('a').on("click", interceptClick);
        	$('area').on("click", interceptClick);
        });
        ```

    - 성능 데이터 발송
    
        ```javascript
        function interceptClick(e) {
            var href = this.href;
            var target = this.target;

            var callUuid = randomUUID();
            var request_timestamp = new Date().getTime();
            var request_event = {
                stage: 'HTTP_REQUEST',
                uuid: callUuid,
                clientId: clientIP,
                referrer: window.location.href,
                targetUrl: href,
                method: 'GET',
                requestTimestamp: request_timestamp
            }

            $.post('http://fresto1.owlab.com:9999/feedUIEvent',request_event); 

            $.ajax({
                type: 'GET',
                beforeSend: function(request) {
                    request.setRequestHeader('fresto-uuid', callUuid);
                },
                url: href, 
                success: function(data) { 
                	var response_timestamp = new Date().getTime();
                	var response_event = {
                        stage: 'HTTP_RESPONSE',
                        uuid: callUuid,
                        clientId: clientIP,
                        referrer: window.location.href,
                        targetUrl: href,
                        method: 'GET',
                        requestTimestamp: request_timestamp,
                        responseTimestamp: response_timestamp,
                        elapsedTime: (response_timestamp - request_timestamp),
                        httpStatus: 200
                	}
                	$.post('http://fresto1.owlab.com:9999/feedUIEvent', response_event); 
                	window.history.pushState('Programmed State','JPetStore', href);
                	$('body').html(data); 
                	//document.write(data);
                }
            });

            // To disable the default action.
            e.preventDefault();
        }
        ```
    - 서버 수집 쪽에 CORS 처리 필요

- 서버 구간 별 성능 데이터 발송
    - 성능 데이터 항목
        - 클래스, 메서드, TimeStamp, 쿼리문
    - 성능 데이터 수집 방식
        - In
            - Servlet : Servlet Filter
            - Controller : SpringMVC Interceptor preHandle
            - Service : SpringAOP @Before Advice implements MethodInterceptor
            - DAO : SpringAOP @Before Advice implements MethodInterceptor
        - Out
            - DAO : SpringAOP @After Advice implements MethodInterceptor
            - Service : SpringAOP @After Advice implements MethodInterceptor
            - Controller : SpringMVC Interceptor postHandle
            - View : SpringMVC Interceptor afterCompletion
    - 성능 데이터 발송
        - Aspect 내에서 ZeroMQ로 EventHub로 발송


# gradnet
- 어려웠던 점, 해결 사례
    - 위변조 방지 처리된 PDF
        - 제출 PDF를 하나로 합쳐달라는 요구사항
        - 위변조 방지 PDF는 합칠 때 오류, 업로드 시 합침 테스트로 위변조 방지 PDF 필터링
    - BIRT 라이브러리
        - HTTP 요청으로만 동작하던 BIRT 라이브러리
        - 내부 메서드에서 호출 가능한 방식으로 재구성
    - S3 배치 다운로드
        - s3object를 큐에 담아놓고 나중에 로컬에 저장하게 구성되어 간헐적으로 연결 리셋
        - s3object에서 바로 inputstream을 뽑아서 바로 로컬에 저장

# 영어 자기 소개

I feel happy to have an interview for a job in a good company like SK planet. My name is Oh, Myung Woon. I'm a software engineer who delights in programming.

I've been using Java as a main language. I have made a lot of Java web applications and a UML modeling tool which is not so common in Korea. I could go deeper into the OOP thanks to the development of that UML modeling tool.

I enjoy learning something new, and I'm in WebGL which can make high performance 3D or 2D graphics in the web browser. And I'm also studying design patterns in JavaScript in some developer community. Recently I started reading a book on blockchain.  

I think I might be the right man for this job because I have experiences in working with Americans. I was a KATUSA, so I carried out my 26-month military duty in the United States Army. Although I did not have that much chance to work with English speaking people since then, still I can communicate in English better than the average software engineer in Korea.